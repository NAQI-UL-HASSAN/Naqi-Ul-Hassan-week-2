# 8-bit ALU in SystemVerilog

## Problem Statement

This project implements an 8-bit Arithmetic Logic Unit (ALU) that performs various arithmetic and logical operations on two 8-bit signed inputs. The ALU is a fundamental component in digital systems and processors, capable of executing multiple operations based on a control signal.

The ALU needs to:
- Perform arithmetic operations (addition, subtraction)
- Execute logical operations (AND, OR, XOR, NOT)
- Handle bit shifting operations (left shift, right shift)
- Generate status flags (zero, carry, overflow) for conditional operations

## Approach

### Design Architecture

The 8-bit ALU is implemented using SystemVerilog with the following specifications:

**Inputs:**
- `a[7:0]` - First 8-bit signed operand
- `b[7:0]` - Second 8-bit signed operand  
- `op_sel[2:0]` - 3-bit operation selector

**Outputs:**
- `result[7:0]` - 8-bit result of the operation
- `zero` - Flag indicating if result is zero
- `carry` - Carry flag for arithmetic operations
- `overflow` - Overflow flag for signed arithmetic

### Operation Set

| op_sel | Operation | Description |
|--------|-----------|-------------|
| 000    | Addition  | result = a + b |
| 001    | Subtraction | result = a - b |
| 010    | AND       | result = a & b |
| 011    | OR        | result = a \| b |
| 100    | XOR       | result = a ^ b |
| 101    | NOT       | result = ~a |
| 110    | Left Shift | result = a << 1 |
| 111    | Right Shift | result = a >> 1 |

### Implementation Details

- **Combinational Logic**: All operations are implemented using `always_comb` block for immediate response
- **Overflow Detection**: Properly handles signed arithmetic overflow using sign bit analysis
- **Carry Generation**: Uses 9-bit temporary variable to capture carry from MSB
- **Flag Generation**: Zero flag is automatically generated by comparing result with zero

## How to Run

Run the simulation on QuestaSim. The testbench file `Alu_8bit_tb.sv` contains comprehensive test cases that verify all ALU operations and edge cases.

## Examples

### Test Case Analysis

The testbench includes the following test scenarios:

1. **Addition of zeros**: `a=0, b=0, op=000`
   - Expected: `result=0, zero=1, carry=0, overflow=0`

2. **Normal addition**: `a=15, b=50, op=000`
   - Expected: `result=65, zero=0, carry=0, overflow=0`

3. **Subtraction with negative result**: `a=0x9A, b=0x32, op=001`
   - Expected: `result=0x68, carry=1`

4. **Bitwise AND**: `a=0xFE, b=0x0F, op=010`
   - Expected: `result=0x0E`

5. **Bitwise OR**: `a=0xFF, b=0x0F, op=011`
   - Expected: `result=0xFF`

6. **Bitwise XOR**: `a=0xAB, b=0x55, op=100`
   - Expected: `result=0xFE`

7. **Bitwise NOT**: `a=0x0F, op=101`
   - Expected: `result=0xF0`

8. **Left shift with carry**: `a=0x81, op=110`
   - Expected: `result=0x02, carry=1`

9. **Right shift**: `a=0x82, op=111`
   - Expected: `result=0x41`

### Key Features Demonstrated

- **Overflow Detection**: Properly detects when signed arithmetic results exceed the 8-bit range
- **Carry Propagation**: Accurately generates carry flags for addition and subtraction
- **Logical Operations**: Implements all basic bitwise operations
- **Shift Operations**: Handles both left and right shifts with appropriate carry generation
- **Status Flags**: Generates zero, carry, and overflow flags for processor integration

The design ensures robust operation across all test cases and provides a solid foundation for integration into larger digital systems.